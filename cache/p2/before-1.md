先对目前存在的问题进行讨论

是的，期望的行为是用户只需通过README学习可用的command即可，通过快捷命令触发流程启动，也无需关心skills，它被command自动触发学习和使用，

我认为需要封装的操作是一些流程与形式上的操作，以此减少不确定性并减少token污染减少不必要的LLM注意，
把核心的分析、思考、业务内容交给LLM不加限制竭尽所能尽情发挥，
我这里有一点前期设计草案，

这套系统开发好后我希望成品是3项：
- 一个可供用户快速上手且能引导用户根据需要进行深入了解的README.md
- 一个可以快速安装的插件市场（在README中提供快捷指令）
- 一套实现了目标程序系统的项目目录

我希望的下发/分享方式是把这1个文档+2个目录打包为一个压缩包分享（先以此为暂定目标，当该体系经验证可用且高效后再考虑更好的形式：再把插件市场迁入远程仓库，把程序投放到一些包托管平台，便于快速安装，然后只需以网页或文档的形式分享README即可），

@aide-requirements.md 是一个我原本暂定的细则文档（如果它有任何不合理之处，你都可以质疑，这只是个草案，不要被它的定式限制），现在需要你根据我前述的需求，评估这个文档是否满足：仅以这一份文档为核心，辅以原 ai-agent-memory/ 和 docs/ 目录下的信息，开始实际开发任务，得到3项最终产出

关于 @aide-requirements.md 的补充：
1. prep和exec的细节都要从原ai-agent-memory目录下的相关文档中获取，
2. 其实我希望你可以完全忽略我在aide-requirements.md中aide程序的细节设计，
    - 就是说，保留`aide env`和`aide progress`等主要支项（这个也可以忽略，不遵循，仅部分参考，后续可以增添或删减），但完全忽略`aide env check`、`aid env ensure`、`aide progress init`等更细节的内容，还包括具体的输入输出数据结构等，
    - 因为我希望你可以引导我对aide程序体系进行重新设计，部分参考原本的设计，找出可能存在的不足，可以完善的部分，可能存在的伪需求，可以删减的部分，
3. 关于待定项的交互流程，我想实现一个程序（最终要把它集成到aide中，以aide为入口启动），启动这个程序后，它会读取相关的数据文件（用户提出的原始任务文档及其他本次任务涉及到的文件、LLM分析得出的待定项数据），基于这些数据渲染成对用户友好的web界面，提供网页的HTTP链接供用户访问，用户在网页界面中以图形化的方式交互式操作数据，程序把用户的操作结果（用户的决定）存储到一个新的数据文件，然后LLM请求用户意见结果时，aide读取这个文件把用户的决定反馈给LLM
4. 我希望最外层的aide入口封装使用平台的shell脚本，但仅仅只是封装部分，这个封装的任务是检查python虚拟环境或系统环境的python，然后通过检测到的python执行真正的python入口程序，
    - 封装部分仅负责检测python并执行真正的入口，在检测到不存在时抛出致命错误，需要用户处理好至少先提供一个可用的基本的python3才能继续
    - 封装部分教轻量，可以为win、linux/mac单独编写也不会太麻烦
    - 由封装调用真正的python入口程序后，处理更核心的逻辑，
    - 使用python是为了减少统一跨平台、开发、调试与测试运行的成本，同时还可以作为胶水语言在适当的时候引入其他语言更好的完成部分任务，比如前面说的处理待定项交互的程序，就很适合用ts+react+nextjs这样的全栈技术栈来实现，同时兼顾界面和后端，还能快速落地，前端比flutter轻量，后端比rust轻量，且性能完全满足需求，
